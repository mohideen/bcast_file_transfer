#!/usr/bin/env ruby

require 'bcast_file_transfer'

options = BcastFileTransfer::OptParse.parse(ARGV)

config_file = options['config_file']

unless File.exist?('config.yml') ||
       (!config_file.nil? && File.exist?(config_file))
  STDERR.push 'ERROR: Please provide a configuration file'
  exit
end

config_hash = if config_file
                YAML.load_file(config_file)
              else
                # Load configuration from file
                YAML.load_file('config.yml')
              end

BcastFileTransfer::Logging.initialize(config_hash['logger.logfile'], config_hash['logger.level'])

bcast_file_transfer = BcastFileTransfer::BcastFileTransfer.new
# Initialization
logger = BcastFileTransfer::Logging.logger_for(self.class.name)

src_dir = config_hash['src_dir']
destination_results = []
destination_servers = config_hash['destination_servers'] || []
destination_buckets = config_hash['destination_buckets'] || []
destinations = []

destination_servers.each do |server|
  server['type'] = 'server'
  destinations << server
end

destination_buckets.each do |bucket|
  bucket['type'] = 'bucket'
  destinations << bucket
end

# For each destination...
destinations.each do |dest|
  transfer_results = []
  dest_type = dest['type']
  dest_identity = dest_type == 'server' ? dest['server'] : dest['bucket']

  # Determine which files need to be transferred
  comparison_result = bcast_file_transfer.files_to_transfer(dest_type, dest, src_dir)

  unless comparison_result.success?
    # Could not get list of files to transfer, so skip to next server
    destination_results << BcastFileTransfer::DestinationResult.new(
      dest_identity, dest_type, comparison_result.dest_directory,
      dest['disable_move_on_failure'], comparison_result, transfer_results
    )
    next
  end

  transfer_files = comparison_result.transfer_files
  logger.debug "transfer_files: #{transfer_files}"

  # Transfer each file to the destination server
  transfer_files.each do |file|
    result = bcast_file_transfer.transfer_file(dest_type, dest, src_dir, file)
    transfer_results << result
  end

  destination_results << BcastFileTransfer::DestinationResult.new(
    dest_identity, dest_type, comparison_result.dest_directory,
    dest['disable_move_on_failure'], comparison_result, transfer_results
  )
end

# Move successfully transferred files
all_transfers = destination_results.flat_map(&:transfer_results)
successful_transfers = all_transfers.select(&:success?)
success_files = successful_transfers.map(&:file).uniq

move_files_after_successful_transfer = config_hash['move_files_after_successful_transfer']

# Determine whether to actually do the move, based on the
# 'move_files_after_successful_transfer' config, and whether any
# destinations marked with "disable_move_on_failure" has failures
failed_destinations = destination_results.reject(&:success?)
critical_destinations_failed = failed_destinations.map(&:disable_move_on_failure).any?

prune_results = []
move_results = []

if move_files_after_successful_transfer && !critical_destinations_failed
  processed_files = success_files
  succesful_transfer_dir = config_hash['succesful_transfer_dir']
  move_results = bcast_file_transfer.move_files_after_transfer(processed_files, src_dir, succesful_transfer_dir)

  # Prune any empty directories
  prune_subdirectories = config_hash['prune_empty_subdirectories']
  prune_results = bcast_file_transfer.prune_empty_subdirectories(src_dir) if prune_subdirectories
end

# Send email describing results
script_result = BcastFileTransfer::ScriptResult.new(config_hash, destination_results, move_results, prune_results)
bcast_file_transfer.send_mail(config_hash, script_result)
